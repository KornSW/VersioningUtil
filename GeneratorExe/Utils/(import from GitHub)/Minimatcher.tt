<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# 
// THIS T4 TEMPLATE DOWNLOADs SOURCECODE VIA HTTP AND GENERATES A FILE FROM IT... (by T.Korn - 21.09.2018)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CONFIG:                                                                                                                 //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    string fileDownloadUrl = "https://raw.githubusercontent.com/SLaks/Minimatch/master/Minimatch/Minimatcher.cs";
    string projectUrl = "https://github.com/SLaks/Minimatch";

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    string content = "//-----------------------------------------------------------------------\n//<auto-generated>\n// THIS CODE IS AN AUTOMATIC MIRROR OF:\n// " + fileDownloadUrl + "\n// Project: " + projectUrl + "(thanks to the autor!)\n//</auto-generated>\n//-----------------------------------------------------------------------\n\n{usings}\n";
    try {
      using (var wc = new System.Net.WebClient()) {
        content = content + wc.DownloadString(fileDownloadUrl);
      }
      string sourceInfo = "Mirrored file from GitHub";
      string vers = DateTime.Now.ToShortDateString();

      content = EnsureUsing(content, "System.CodeDom.Compiler");
      content = EnsureUsing(content, "System.Runtime.CompilerServices");

      content = content.Replace("{usings}\n","");

      string compilerGeneratedAttributes = "[CompilerGeneratedAttribute()][GeneratedCode( tool:\"" + sourceInfo + "\", version:\"" + vers + "\")]";

      content = content.Replace("public class",     compilerGeneratedAttributes + "\n    internal class");
      content = content.Replace("public interface", compilerGeneratedAttributes + "\n    internal interface");
      content = content.Replace("public enum",      compilerGeneratedAttributes + "\n    internal enum");
      content = content.Replace("class ", "partial class ");
    }
    catch (Exception ex) {
      content = "Cannot download '" + fileDownloadUrl  + "': " + ex.Message;
    }
///////////////////// HERE STARTS CUSTOM PATCHING //////////////////////////////////////////////////////////////////


  content = content.Replace("namespace Minimatch", "namespace Utils");


///////////////////// HERE  CUSTOM PATCHING ////////////////////////////////////////////////////////////////////////
#>
<#= content #>
///////////////////// HERE STARTS OWN ADDITIONAL CODE (can be maintained in the .tt file!) /////////////////////////

namespace Utils {

  partial class Minimatcher {

    public static IEnumerable<string> FilterMulti(IEnumerable<string> list, string multiPattern){
      var opt = new Options();
      opt.NoCase = true;
      var input = list.Select((s) => s.Replace("\\", "/")).ToArray();
      var patterns = multiPattern.Replace("\\", "/").Split(";");
      IEnumerable<string> result = new string[] { };
      foreach (var pattern in patterns.Where((p) => !p.StartsWith("!"))) {
        result = result.Union(Minimatcher.Filter(input, pattern, opt));
      }
      foreach (var pattern in patterns.Where((p) => p.StartsWith("!"))) {
        result = result.Where((f) => Minimatcher.Check(f, pattern, opt));
      }
      return result.Distinct().Select((f) => f.Replace("/", "\\"));
    }

  }

 }
<#+ 
///////////////////// HERE ENDS OWN ADDITIONAL CODE ///////////////////////////////////////////////////////////////
  string EnsureUsing(string content, string ns){  
    if(!content.Contains("using " + ns + ";")){
      content = content.Replace("{usings}\n","using " + ns + ";\n{usings}\n");    
    }
    return content;
  }
#>